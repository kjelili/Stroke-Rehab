"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseMedia = void 0;
const buffer_iterator_1 = require("./buffer-iterator");
const emit_available_info_1 = require("./emit-available-info");
const get_fields_from_callbacks_1 = require("./get-fields-from-callbacks");
const has_all_info_1 = require("./has-all-info");
const log_1 = require("./log");
const parse_video_1 = require("./parse-video");
const from_fetch_1 = require("./readers/from-fetch");
const parser_state_1 = require("./state/parser-state");
const parseMedia = async function ({ src, fields: _fieldsInReturnValue, reader: readerInterface = from_fetch_1.fetchReader, onAudioTrack, onVideoTrack, signal, logLevel = 'info', onParseProgress, ...more }) {
    let iterator = null;
    let parseResult = null;
    const fieldsInReturnValue = _fieldsInReturnValue !== null && _fieldsInReturnValue !== void 0 ? _fieldsInReturnValue : {};
    const fields = (0, get_fields_from_callbacks_1.getFieldsFromCallback)({
        fields: fieldsInReturnValue,
        callbacks: more,
    });
    const { reader, contentLength, name, contentType, supportsContentRange: readerSupportsContentRange, } = await readerInterface.read(src, null, signal);
    const supportsContentRange = readerSupportsContentRange &&
        !(typeof process !== 'undefined' &&
            typeof process.env !== 'undefined' &&
            process.env.DISABLE_CONTENT_RANGE === 'true');
    const state = (0, parser_state_1.makeParserState)({
        hasAudioTrackHandlers: Boolean(onAudioTrack),
        hasVideoTrackHandlers: Boolean(onVideoTrack),
        signal,
        getIterator: () => iterator,
        fields,
        onAudioTrack: onAudioTrack !== null && onAudioTrack !== void 0 ? onAudioTrack : null,
        onVideoTrack: onVideoTrack !== null && onVideoTrack !== void 0 ? onVideoTrack : null,
        supportsContentRange,
    });
    let currentReader = reader;
    const returnValue = {};
    const moreFields = more;
    const triggerInfoEmit = () => {
        const availableInfo = (0, has_all_info_1.getAvailableInfo)({
            fieldsToFetch: fields,
            state,
        });
        (0, emit_available_info_1.emitAvailableInfo)({
            hasInfo: availableInfo,
            callbacks: moreFields,
            fieldsInReturnValue,
            parseResult,
            state,
            returnValue,
            contentLength,
            name,
            mimeType: contentType,
        });
    };
    triggerInfoEmit();
    while (parseResult === null || parseResult.status === 'incomplete') {
        while (true) {
            if (signal === null || signal === void 0 ? void 0 : signal.aborted) {
                throw new Error('Aborted');
            }
            const result = await currentReader.reader.read();
            if (iterator) {
                if (!result.done) {
                    iterator.addData(result.value);
                }
            }
            else {
                if (result.done) {
                    throw new Error('Unexpectedly reached EOF');
                }
                iterator = (0, buffer_iterator_1.getArrayBufferIterator)(result.value, contentLength !== null && contentLength !== void 0 ? contentLength : 1000000000);
            }
            if (iterator.bytesRemaining() >= 0) {
                break;
            }
            if (result.done) {
                break;
            }
        }
        if (!iterator) {
            throw new Error('Unexpected null');
        }
        await (onParseProgress === null || onParseProgress === void 0 ? void 0 : onParseProgress({
            bytes: iterator.counter.getOffset(),
            percentage: contentLength
                ? iterator.counter.getOffset() / contentLength
                : null,
            totalBytes: contentLength,
        }));
        triggerInfoEmit();
        if (parseResult && parseResult.status === 'incomplete') {
            log_1.Log.trace(logLevel, 'Continuing parsing of file, currently at position', iterator.counter.getOffset());
            parseResult = await parseResult.continueParsing();
        }
        else {
            parseResult = await (0, parse_video_1.parseVideo)({
                iterator,
                state,
                signal: signal !== null && signal !== void 0 ? signal : null,
                logLevel,
                fields,
                mimeType: contentType,
                contentLength,
                name,
            });
        }
        if (parseResult.status === 'incomplete' && parseResult.skipTo !== null) {
            state.increaseSkippedBytes(parseResult.skipTo - iterator.counter.getOffset());
        }
        if ((0, has_all_info_1.hasAllInfo)({
            fields,
            state,
        })) {
            log_1.Log.verbose(logLevel, 'Got all info, skipping to the end.');
            if (contentLength !== null) {
                state.increaseSkippedBytes(contentLength - iterator.counter.getOffset());
            }
            break;
        }
        if (parseResult.status === 'incomplete' && parseResult.skipTo !== null) {
            if (!supportsContentRange) {
                throw new Error('Content-Range header is not supported by the reader, but was asked to seek');
            }
            if (parseResult.skipTo === contentLength) {
                log_1.Log.verbose(logLevel, 'Skipped to end of file, not fetching.');
                break;
            }
            log_1.Log.verbose(logLevel, `Skipping over video data from position ${iterator.counter.getOffset()} -> ${parseResult.skipTo}`);
            currentReader.abort();
            const { reader: newReader } = await readerInterface.read(src, parseResult.skipTo, signal);
            currentReader = newReader;
            iterator.skipTo(parseResult.skipTo, true);
        }
    }
    log_1.Log.verbose(logLevel, 'Finished parsing file');
    const hasInfo = Object.keys(fields).reduce((acc, key) => {
        if (fields === null || fields === void 0 ? void 0 : fields[key]) {
            acc[key] = true;
        }
        return acc;
    }, {});
    // Force assign
    (0, emit_available_info_1.emitAvailableInfo)({
        hasInfo,
        callbacks: moreFields,
        fieldsInReturnValue,
        parseResult,
        state,
        returnValue,
        contentLength,
        mimeType: contentType,
        name,
    });
    currentReader.abort();
    iterator === null || iterator === void 0 ? void 0 : iterator.destroy();
    state.callbacks.tracks.ensureHasTracksAtEnd();
    return returnValue;
};
exports.parseMedia = parseMedia;
