"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseVideo = void 0;
const process_box_1 = require("./boxes/iso-base-media/process-box");
const parse_box_1 = require("./boxes/riff/parse-box");
const next_pes_header_store_1 = require("./boxes/transport-stream/next-pes-header-store");
const parse_transport_stream_1 = require("./boxes/transport-stream/parse-transport-stream");
const parse_webm_header_1 = require("./boxes/webm/parse-webm-header");
const errors_1 = require("./errors");
const log_1 = require("./log");
const parseVideo = ({ iterator, state, signal, logLevel, fields, mimeType, contentLength, name, }) => {
    if (iterator.bytesRemaining() === 0) {
        return Promise.reject(new Error('no bytes'));
    }
    const fileType = iterator.detectFileType();
    if (fileType.type === 'riff') {
        log_1.Log.verbose(logLevel, 'Detected RIFF container');
        state.structure.setStructure({
            type: 'riff',
            boxes: [],
        });
        return Promise.resolve((0, parse_box_1.parseRiff)({ iterator, state, fields }));
    }
    if (fileType.type === 'iso-base-media') {
        log_1.Log.verbose(logLevel, 'Detected ISO Base Media container');
        const initialBoxes = [];
        state.structure.setStructure({
            type: 'iso-base-media',
            boxes: initialBoxes,
        });
        return (0, process_box_1.parseIsoBaseMediaBoxes)({
            iterator,
            maxBytes: Infinity,
            allowIncompleteBoxes: true,
            initialBoxes,
            state,
            continueMdat: false,
            signal,
            logLevel,
            fields,
        });
    }
    if (fileType.type === 'webm') {
        log_1.Log.verbose(logLevel, 'Detected Matroska container');
        state.structure.setStructure({
            boxes: [],
            type: 'matroska',
        });
        return (0, parse_webm_header_1.parseWebm)({ counter: iterator, state, fields });
    }
    if (fileType.type === 'transport-stream') {
        log_1.Log.verbose(logLevel, 'Detected MPEG-2 Transport Stream');
        state.structure.setStructure({
            boxes: [],
            type: 'transport-stream',
        });
        return (0, parse_transport_stream_1.parseTransportStream)({
            iterator,
            state,
            streamBuffers: new Map(),
            fields,
            nextPesHeaderStore: (0, next_pes_header_store_1.makeNextPesHeaderStore)(),
        });
    }
    if (fileType.type === 'mp3') {
        return Promise.reject(new errors_1.IsAnUnsupportedAudioTypeError({
            message: 'MP3 files are not yet supported',
            mimeType,
            sizeInBytes: contentLength,
            fileName: name,
            audioType: 'mp3',
        }));
    }
    if (fileType.type === 'wav') {
        return Promise.reject(new errors_1.IsAnUnsupportedAudioTypeError({
            message: 'WAV files are not yet supported',
            mimeType,
            sizeInBytes: contentLength,
            fileName: name,
            audioType: 'wav',
        }));
    }
    if (fileType.type === 'aac') {
        return Promise.reject(new errors_1.IsAnUnsupportedAudioTypeError({
            message: 'AAC files are not yet supported',
            mimeType,
            sizeInBytes: contentLength,
            fileName: name,
            audioType: 'aac',
        }));
    }
    if (fileType.type === 'gif') {
        return Promise.reject(new errors_1.IsAGifError({
            message: 'GIF files are not yet supported',
            mimeType,
            sizeInBytes: contentLength,
            fileName: name,
        }));
    }
    if (fileType.type === 'pdf') {
        return Promise.reject(new errors_1.IsAPdfError({
            message: 'GIF files are not supported',
            mimeType,
            sizeInBytes: contentLength,
            fileName: name,
        }));
    }
    if (fileType.type === 'bmp' ||
        fileType.type === 'jpeg' ||
        fileType.type === 'png' ||
        fileType.type === 'webp') {
        return Promise.reject(new errors_1.IsAnImageError({
            message: 'Image files are not supported',
            imageType: fileType.type,
            dimensions: fileType.dimensions,
            mimeType,
            sizeInBytes: contentLength,
            fileName: name,
        }));
    }
    if (fileType.type === 'unknown') {
        return Promise.reject(new errors_1.IsAnUnsupportedFileTypeError({
            message: 'Unknown file format',
            mimeType,
            sizeInBytes: contentLength,
            fileName: name,
        }));
    }
    return Promise.reject(new Error('Unknown video format ' + fileType));
};
exports.parseVideo = parseVideo;
