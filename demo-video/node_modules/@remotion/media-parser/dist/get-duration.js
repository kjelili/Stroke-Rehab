"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasSlowDuration = exports.hasDuration = exports.getDuration = exports.isMatroska = void 0;
const get_sample_positions_from_track_1 = require("./boxes/iso-base-media/get-sample-positions-from-track");
const traversal_1 = require("./boxes/iso-base-media/traversal");
const traversal_2 = require("./boxes/riff/traversal");
const get_tracks_1 = require("./get-tracks");
const getDurationFromMatroska = (segments) => {
    const mainSegment = segments.find((s) => s.type === 'Segment');
    if (!mainSegment || mainSegment.type !== 'Segment') {
        return null;
    }
    const { value: children } = mainSegment;
    if (!children) {
        return null;
    }
    const infoSegment = children.find((s) => s.type === 'Info');
    const relevantBoxes = [
        ...mainSegment.value,
        ...(infoSegment && infoSegment.type === 'Info' ? infoSegment.value : []),
    ];
    const timestampScale = relevantBoxes.find((s) => s.type === 'TimestampScale');
    if (!timestampScale || timestampScale.type !== 'TimestampScale') {
        return null;
    }
    const duration = relevantBoxes.find((s) => s.type === 'Duration');
    if (!duration || duration.type !== 'Duration') {
        return null;
    }
    return (duration.value.value / timestampScale.value.value) * 1000;
};
const isMatroska = (boxes) => {
    const matroskaBox = boxes.find((b) => b.type === 'Segment');
    return matroskaBox;
};
exports.isMatroska = isMatroska;
const getDurationFromIsoBaseMedia = (structure, parserState) => {
    const moovBox = (0, traversal_1.getMoovBox)(structure.boxes);
    if (!moovBox) {
        return null;
    }
    const moofBox = (0, traversal_1.getMoofBox)(structure.boxes);
    const mvhdBox = (0, traversal_1.getMvhdBox)(moovBox);
    if (!mvhdBox) {
        return null;
    }
    if (mvhdBox.type !== 'mvhd-box') {
        throw new Error('Expected mvhd-box');
    }
    if (mvhdBox.durationInSeconds > 0) {
        return mvhdBox.durationInSeconds;
    }
    const tracks = (0, get_tracks_1.getTracks)(structure, parserState);
    const allTracks = [
        ...tracks.videoTracks,
        ...tracks.audioTracks,
        ...tracks.otherTracks,
    ];
    const allSamples = allTracks.map((t) => {
        const { timescale: ts } = t;
        const samplePositions = (0, get_sample_positions_from_track_1.getSamplePositionsFromTrack)(t.trakBox, moofBox);
        const highest = samplePositions === null || samplePositions === void 0 ? void 0 : samplePositions.map((sp) => (sp.cts + sp.duration) / ts).reduce((a, b) => Math.max(a, b), 0);
        return highest !== null && highest !== void 0 ? highest : 0;
    });
    const highestTimestamp = Math.max(...allSamples);
    return highestTimestamp;
};
const getDurationFromAvi = (structure) => {
    const strl = (0, traversal_2.getStrlBoxes)(structure);
    const lengths = [];
    for (const s of strl) {
        const strh = (0, traversal_2.getStrhBox)(s.children);
        if (!strh) {
            throw new Error('No strh box');
        }
        const samplesPerSecond = strh.rate / strh.scale;
        const streamLength = strh.length / samplesPerSecond;
        lengths.push(streamLength);
    }
    return Math.max(...lengths);
};
const getDuration = (structure, parserState) => {
    if (structure.type === 'matroska') {
        return getDurationFromMatroska(structure.boxes);
    }
    if (structure.type === 'iso-base-media') {
        return getDurationFromIsoBaseMedia(structure, parserState);
    }
    if (structure.type === 'riff') {
        return getDurationFromAvi(structure);
    }
    if (structure.type === 'transport-stream') {
        return null;
    }
    throw new Error('Has no duration ' + structure);
};
exports.getDuration = getDuration;
// `duration` just grabs from metadata, and otherwise returns null
// Therefore just checking if we have tracks
const hasDuration = (structure, parserState) => {
    return (0, get_tracks_1.hasTracks)(structure, parserState);
};
exports.hasDuration = hasDuration;
// `slowDuration` does through everything, and therefore is false
// Unless it it somewhere in the metadata and is non-null
const hasSlowDuration = (structure, parserState) => {
    try {
        return (0, exports.getDuration)(structure, parserState) !== null;
    }
    catch (_a) {
        return false;
    }
};
exports.hasSlowDuration = hasSlowDuration;
