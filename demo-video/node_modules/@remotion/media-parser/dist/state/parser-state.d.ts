import type { AvcPPs, AvcProfileInfo } from '../boxes/avc/parse-avc';
import type { BufferIterator } from '../buffer-iterator';
import type { Options, ParseMediaFields } from '../options';
import type { OnAudioTrack, OnVideoTrack } from '../webcodec-sample-types';
export type InternalStats = {
    skippedBytes: number;
    finalCursorOffset: number;
};
export type SpsAndPps = {
    sps: AvcProfileInfo;
    pps: AvcPPs;
};
export declare const makeParserState: ({ hasAudioTrackHandlers, hasVideoTrackHandlers, signal, getIterator, fields, onAudioTrack, onVideoTrack, supportsContentRange, }: {
    hasAudioTrackHandlers: boolean;
    hasVideoTrackHandlers: boolean;
    signal: AbortSignal | undefined;
    getIterator: () => BufferIterator | null;
    fields: Options<ParseMediaFields>;
    supportsContentRange: boolean;
    onAudioTrack: OnAudioTrack | null;
    onVideoTrack: OnVideoTrack | null;
}) => {
    riff: {
        getAvcProfile: () => SpsAndPps | null;
        onProfile: (profile: SpsAndPps) => Promise<void>;
        registerOnAvcProfileCallback: (callback: (profile: SpsAndPps) => Promise<void>) => void;
        getNextTrackIndex: () => number;
        incrementNextTrackIndex: () => void;
    };
    callbacks: {
        registerVideoSampleCallback: (id: number, callback: import("../webcodec-sample-types").OnVideoSample | null) => Promise<void>;
        onAudioSample: (trackId: number, audioSample: import("../webcodec-sample-types").AudioOrVideoSample) => Promise<void>;
        getSamplesForTrack: (trackId: number) => number;
        onVideoSample: (trackId: number, videoSample: import("../webcodec-sample-types").AudioOrVideoSample) => Promise<void>;
        canSkipTracksState: {
            canSkipTracks: () => boolean;
        };
        registerAudioSampleCallback: (id: number, callback: import("../webcodec-sample-types").OnAudioSample | null) => Promise<void>;
        tracks: {
            hasAllTracks: () => boolean;
            setIsDone: () => void;
            addTrack: (track: import("..").Track) => void;
            getTracks: () => import("..").Track[];
            ensureHasTracksAtEnd: () => void;
        };
        audioSampleCallbacks: Record<number, import("../webcodec-sample-types").OnAudioSample>;
        videoSampleCallbacks: Record<number, import("../webcodec-sample-types").OnVideoSample>;
    };
    getInternalStats: () => InternalStats;
    getSkipBytes: () => number;
    increaseSkippedBytes: (bytes: number) => void;
    keyframes: {
        addKeyframe: (keyframe: import("../options").MediaParserKeyframe) => void;
        getKeyframes: () => import("../options").MediaParserKeyframe[];
    };
    structure: {
        getStructureOrNull: () => import("../parse-result").Structure | null;
        getStructure: () => import("../parse-result").Structure;
        setStructure: (value: import("../parse-result").Structure) => void;
    };
    onAudioTrack: OnAudioTrack | null;
    onVideoTrack: OnVideoTrack | null;
    supportsContentRange: boolean;
    webm: {
        onTrackEntrySegment: import("../boxes/webm/segments").OnTrackEntrySegment;
        getTrackInfoByNumber: (id: number) => import("../boxes/webm/segments/track-entry").TrackInfo;
        setTimestampOffset: (byteOffset: number, timestamp: number) => void;
        getTimestampOffsetForByteOffset: (byteOffset: number) => number | undefined;
        timescale: null;
        getTimescale: () => number;
        setTimescale: (newTimescale: number) => void;
    };
    emittedFields: import("../options").AllOptions<ParseMediaFields>;
    fields: Partial<import("../options").AllOptions<ParseMediaFields>>;
    slowDurationAndFps: {
        addSample: (videoSample: import("../webcodec-sample-types").AudioOrVideoSample) => void;
        getSlowDurationInSeconds: () => number;
        getFps: () => number;
        getSlowNumberOfFrames: () => number;
    };
};
export type ParserState = ReturnType<typeof makeParserState>;
