"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseIsoBaseMediaBoxes = exports.processBox = exports.parseMdatPartially = void 0;
const get_tracks_1 = require("../../get-tracks");
const has_all_info_1 = require("../../has-all-info");
const may_skip_video_data_1 = require("../../may-skip-video-data/may-skip-video-data");
const register_track_1 = require("../../register-track");
const esds_1 = require("./esds/esds");
const ftyp_1 = require("./ftyp");
const make_track_1 = require("./make-track");
const mdat_1 = require("./mdat/mdat");
const mdhd_1 = require("./mdhd");
const hdlr_1 = require("./meta/hdlr");
const ilst_1 = require("./meta/ilst");
const moov_1 = require("./moov/moov");
const mvhd_1 = require("./mvhd");
const av1c_1 = require("./stsd/av1c");
const avcc_1 = require("./stsd/avcc");
const colr_1 = require("./stsd/colr");
const ctts_1 = require("./stsd/ctts");
const hvcc_1 = require("./stsd/hvcc");
const keys_1 = require("./stsd/keys");
const mebx_1 = require("./stsd/mebx");
const pasp_1 = require("./stsd/pasp");
const stco_1 = require("./stsd/stco");
const stsc_1 = require("./stsd/stsc");
const stsd_1 = require("./stsd/stsd");
const stss_1 = require("./stsd/stss");
const stsz_1 = require("./stsd/stsz");
const stts_1 = require("./stsd/stts");
const tfdt_1 = require("./tfdt");
const tfhd_1 = require("./tfhd");
const tkhd_1 = require("./tkhd");
const trak_1 = require("./trak/trak");
const traversal_1 = require("./traversal");
const trun_1 = require("./trun");
const getChildren = async ({ boxType, iterator, bytesRemainingInBox, state, signal, logLevel, fields, }) => {
    const parseChildren = boxType === 'mdia' ||
        boxType === 'minf' ||
        boxType === 'stbl' ||
        boxType === 'udta' ||
        boxType === 'moof' ||
        boxType === 'dims' ||
        boxType === 'meta' ||
        boxType === 'wave' ||
        boxType === 'traf' ||
        boxType === 'stsb';
    if (parseChildren) {
        const boxes = [];
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        const parsed = await (0, exports.parseIsoBaseMediaBoxes)({
            iterator,
            maxBytes: bytesRemainingInBox,
            allowIncompleteBoxes: false,
            initialBoxes: boxes,
            state,
            continueMdat: false,
            signal,
            logLevel,
            fields,
        });
        if (parsed.status === 'incomplete') {
            throw new Error('Incomplete boxes are not allowed');
        }
        return boxes;
    }
    if (bytesRemainingInBox < 0) {
        throw new Error('Box size is too big ' + JSON.stringify({ boxType }));
    }
    iterator.discard(bytesRemainingInBox);
    return [];
};
const parseMdatPartially = async ({ iterator, boxSize, fileOffset, parsedBoxes, state, signal, }) => {
    const box = await (0, mdat_1.parseMdat)({
        data: iterator,
        size: boxSize,
        fileOffset,
        existingBoxes: parsedBoxes,
        state,
        signal,
        maySkipSampleProcessing: state.supportsContentRange,
    });
    if ((box.status === 'samples-processed' || box.status === 'samples-buffered') &&
        box.fileOffset + boxSize === iterator.counter.getOffset()) {
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    return {
        type: 'partial-mdat-box',
        boxSize,
        fileOffset,
    };
};
exports.parseMdatPartially = parseMdatPartially;
const processBox = async ({ iterator, allowIncompleteBoxes, parsedBoxes, state, signal, logLevel, fields, }) => {
    const fileOffset = iterator.counter.getOffset();
    const bytesRemaining = iterator.bytesRemaining();
    const boxSizeRaw = iterator.getFourByteNumber();
    // If `boxSize === 1`, the 8 bytes after the box type are the size of the box.
    if ((boxSizeRaw === 1 && iterator.bytesRemaining() < 12) ||
        iterator.bytesRemaining() < 4) {
        iterator.counter.decrement(iterator.counter.getOffset() - fileOffset);
        if (allowIncompleteBoxes) {
            return {
                type: 'incomplete',
            };
        }
        throw new Error(`Expected box size of ${bytesRemaining}, got ${boxSizeRaw}. Incomplete boxes are not allowed.`);
    }
    if (boxSizeRaw === 0) {
        return {
            type: 'complete',
            box: {
                type: 'void-box',
                boxSize: 0,
            },
            size: 4,
            skipTo: null,
        };
    }
    const boxType = iterator.getByteString(4, false);
    const boxSize = boxSizeRaw === 1 ? iterator.getEightByteNumber() : boxSizeRaw;
    if (bytesRemaining < boxSize) {
        if (boxType === 'mdat') {
            // Check if the moov atom is at the end
            const shouldSkip = (0, may_skip_video_data_1.maySkipVideoData)({ state }) ||
                (!(0, get_tracks_1.hasTracks)({ type: 'iso-base-media', boxes: parsedBoxes }, state) &&
                    state.supportsContentRange);
            if (shouldSkip) {
                const skipTo = fileOffset + boxSize;
                const bytesToSkip = skipTo - iterator.counter.getOffset();
                // If there is a huge mdat chunk, we can skip it because we don't need it for the metadata
                if (bytesToSkip > 1000000) {
                    return {
                        type: 'complete',
                        box: {
                            type: 'mdat-box',
                            boxSize,
                            fileOffset,
                            status: 'samples-skipped',
                        },
                        size: boxSize,
                        skipTo: fileOffset + boxSize,
                    };
                }
            }
            else {
                return (0, exports.parseMdatPartially)({
                    iterator,
                    boxSize,
                    fileOffset,
                    parsedBoxes,
                    state,
                    signal,
                });
            }
        }
        iterator.counter.decrement(iterator.counter.getOffset() - fileOffset);
        if (allowIncompleteBoxes) {
            return {
                type: 'incomplete',
            };
        }
        throw new Error(`Expected box size of ${bytesRemaining}, got ${boxSize}. Incomplete boxes are not allowed.`);
    }
    if (boxType === 'ftyp') {
        const box = (0, ftyp_1.parseFtyp)({ iterator, size: boxSize, offset: fileOffset });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'colr') {
        const box = (0, colr_1.parseColorParameterBox)({
            iterator,
            size: boxSize,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'mvhd') {
        const box = (0, mvhd_1.parseMvhd)({ iterator, offset: fileOffset, size: boxSize });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'tkhd') {
        const box = (0, tkhd_1.parseTkhd)({ iterator, offset: fileOffset, size: boxSize });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'trun') {
        const box = (0, trun_1.parseTrun)({ iterator, offset: fileOffset, size: boxSize });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'tfdt') {
        const box = (0, tfdt_1.parseTfdt)({ iterator, size: boxSize, offset: fileOffset });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'stsd') {
        const box = await (0, stsd_1.parseStsd)({
            iterator,
            offset: fileOffset,
            size: boxSize,
            state,
            signal,
            fields,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'stsz') {
        const box = (0, stsz_1.parseStsz)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'stco' || boxType === 'co64') {
        const box = (0, stco_1.parseStco)({
            iterator,
            offset: fileOffset,
            size: boxSize,
            mode64Bit: boxType === 'co64',
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'pasp') {
        const box = (0, pasp_1.parsePasp)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'stss') {
        const box = (0, stss_1.parseStss)({
            iterator,
            offset: fileOffset,
            boxSize,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'ctts') {
        const box = (0, ctts_1.parseCtts)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'stsc') {
        const box = (0, stsc_1.parseStsc)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'mebx') {
        const box = await (0, mebx_1.parseMebx)({
            iterator,
            offset: fileOffset,
            size: boxSize,
            state,
            signal,
            fields,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'hdlr') {
        const box = await (0, hdlr_1.parseHdlr)({ iterator, size: boxSize, offset: fileOffset });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'keys') {
        const box = (0, keys_1.parseKeys)({ iterator, size: boxSize, offset: fileOffset });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'ilst') {
        const box = (0, ilst_1.parseIlstBox)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'moov') {
        const box = await (0, moov_1.parseMoov)({
            iterator,
            offset: fileOffset,
            size: boxSize,
            state,
            signal,
            logLevel,
            fields,
        });
        state.callbacks.tracks.setIsDone();
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'trak') {
        const box = await (0, trak_1.parseTrak)({
            data: iterator,
            size: boxSize,
            offsetAtStart: fileOffset,
            state,
            signal,
            logLevel,
            fields,
        });
        const transformedTrack = (0, make_track_1.makeBaseMediaTrack)(box);
        if (transformedTrack) {
            await (0, register_track_1.registerTrack)({
                state,
                track: transformedTrack,
                container: 'mp4',
            });
        }
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'stts') {
        const box = (0, stts_1.parseStts)({
            data: iterator,
            size: boxSize,
            fileOffset,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'avcC') {
        const box = (0, avcc_1.parseAvcc)({
            data: iterator,
            size: boxSize,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'av1C') {
        const box = (0, av1c_1.parseAv1C)({
            data: iterator,
            size: boxSize,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'hvcC') {
        const box = (0, hvcc_1.parseHvcc)({
            data: iterator,
            size: boxSize,
            offset: fileOffset,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'tfhd') {
        const box = (0, tfhd_1.getTfhd)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'mdhd') {
        const box = (0, mdhd_1.parseMdhd)({
            data: iterator,
            size: boxSize,
            fileOffset,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'esds') {
        const box = (0, esds_1.parseEsds)({
            data: iterator,
            size: boxSize,
            fileOffset,
        });
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    if (boxType === 'mdat') {
        const box = await (0, mdat_1.parseMdat)({
            data: iterator,
            size: boxSize,
            fileOffset,
            existingBoxes: parsedBoxes,
            state,
            signal,
            maySkipSampleProcessing: state.supportsContentRange,
        });
        if (box === null) {
            throw new Error('Unexpected null');
        }
        return {
            type: 'complete',
            box,
            size: boxSize,
            skipTo: null,
        };
    }
    const bytesRemainingInBox = boxSize - (iterator.counter.getOffset() - fileOffset);
    const children = await getChildren({
        boxType,
        iterator,
        bytesRemainingInBox,
        state,
        signal,
        logLevel,
        fields,
    });
    return {
        type: 'complete',
        box: {
            type: 'regular-box',
            boxType,
            boxSize,
            children,
            offset: fileOffset,
        },
        size: boxSize,
        skipTo: null,
    };
};
exports.processBox = processBox;
const parseIsoBaseMediaBoxes = async ({ iterator, maxBytes, allowIncompleteBoxes, initialBoxes, state, continueMdat, signal, logLevel, fields, }) => {
    var _a;
    const initialOffset = iterator.counter.getOffset();
    const alreadyHasMdat = (_a = state.structure
        .getStructureOrNull()) === null || _a === void 0 ? void 0 : _a.boxes.find((b) => b.type === 'mdat-box');
    while (iterator.bytesRemaining() > 0 &&
        iterator.counter.getOffset() - initialOffset < maxBytes) {
        const result = continueMdat
            ? await (0, exports.parseMdatPartially)({
                iterator,
                boxSize: continueMdat.boxSize,
                fileOffset: continueMdat.fileOffset,
                parsedBoxes: initialBoxes,
                state,
                signal,
            })
            : await (0, exports.processBox)({
                iterator,
                allowIncompleteBoxes,
                parsedBoxes: initialBoxes,
                state,
                signal,
                logLevel,
                fields,
            });
        if (result.type === 'incomplete') {
            if (Number.isFinite(maxBytes)) {
                throw new Error('maxBytes must be Infinity for top-level boxes');
            }
            return {
                status: 'incomplete',
                continueParsing: () => {
                    return (0, exports.parseIsoBaseMediaBoxes)({
                        iterator,
                        maxBytes,
                        allowIncompleteBoxes,
                        initialBoxes,
                        state,
                        continueMdat: false,
                        signal,
                        logLevel,
                        fields,
                    });
                },
                skipTo: null,
            };
        }
        if (result.type === 'partial-mdat-box') {
            return {
                status: 'incomplete',
                continueParsing: () => {
                    return Promise.resolve((0, exports.parseIsoBaseMediaBoxes)({
                        iterator,
                        maxBytes,
                        allowIncompleteBoxes,
                        initialBoxes,
                        state,
                        continueMdat: result,
                        signal,
                        logLevel,
                        fields,
                    }));
                },
                skipTo: null,
            };
        }
        if (result.box.type === 'mdat-box' && alreadyHasMdat) {
            initialBoxes = initialBoxes.filter((b) => b.type !== 'mdat-box');
            initialBoxes.push(result.box);
            iterator.allowDiscard();
            break;
        }
        else {
            initialBoxes.push(result.box);
            if ((0, has_all_info_1.hasAllInfo)({ fields, state })) {
                return {
                    status: 'done',
                };
            }
        }
        if (result.skipTo !== null) {
            if (!state.supportsContentRange) {
                throw new Error('Content-Range header is not supported by the reader, but was asked to seek');
            }
            return {
                status: 'incomplete',
                continueParsing: () => {
                    return (0, exports.parseIsoBaseMediaBoxes)({
                        iterator,
                        maxBytes,
                        allowIncompleteBoxes,
                        initialBoxes,
                        state,
                        continueMdat: false,
                        signal,
                        logLevel,
                        fields,
                    });
                },
                skipTo: result.skipTo,
            };
        }
        if (iterator.bytesRemaining() < 0) {
            return {
                status: 'incomplete',
                continueParsing: () => {
                    return (0, exports.parseIsoBaseMediaBoxes)({
                        iterator,
                        maxBytes,
                        allowIncompleteBoxes,
                        initialBoxes,
                        state,
                        continueMdat: false,
                        signal,
                        logLevel,
                        fields,
                    });
                },
                skipTo: null,
            };
        }
        iterator.removeBytesRead();
    }
    const mdatState = (0, traversal_1.getMdatBox)(initialBoxes);
    const skipped = (mdatState === null || mdatState === void 0 ? void 0 : mdatState.status) === 'samples-skipped' &&
        !(0, may_skip_video_data_1.maySkipVideoData)({ state }) &&
        state.supportsContentRange;
    const buffered = (mdatState === null || mdatState === void 0 ? void 0 : mdatState.status) === 'samples-buffered' && !(0, may_skip_video_data_1.maySkipVideoData)({ state });
    if (skipped || buffered) {
        return {
            status: 'incomplete',
            continueParsing: () => {
                if (buffered) {
                    iterator.skipTo(mdatState.fileOffset, false);
                }
                return (0, exports.parseIsoBaseMediaBoxes)({
                    iterator,
                    maxBytes,
                    allowIncompleteBoxes: false,
                    initialBoxes,
                    state,
                    continueMdat: false,
                    signal,
                    logLevel,
                    fields,
                });
            },
            skipTo: skipped ? mdatState.fileOffset : null,
        };
    }
    return {
        status: 'done',
    };
};
exports.parseIsoBaseMediaBoxes = parseIsoBaseMediaBoxes;
