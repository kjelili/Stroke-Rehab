"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTransportStream = void 0;
const has_all_info_1 = require("../../has-all-info");
const parse_packet_1 = require("./parse-packet");
const process_stream_buffers_1 = require("./process-stream-buffers");
const parseTransportStream = async ({ iterator, state, streamBuffers, fields, nextPesHeaderStore, }) => {
    const structure = state.structure.getStructure();
    if (structure.type !== 'transport-stream') {
        throw new Error('Invalid structure type');
    }
    if (iterator.bytesRemaining() === 0) {
        await (0, process_stream_buffers_1.processFinalStreamBuffers)({
            streamBufferMap: streamBuffers,
            state,
            structure,
        });
        return Promise.resolve({
            status: 'done',
            segments: structure,
        });
    }
    while (true) {
        if ((0, has_all_info_1.hasAllInfo)({
            fields,
            state,
        })) {
            break;
        }
        if (iterator.bytesRemaining() < 188) {
            return Promise.resolve({
                status: 'incomplete',
                segments: structure,
                skipTo: null,
                continueParsing: () => {
                    return (0, exports.parseTransportStream)({
                        iterator,
                        state,
                        streamBuffers,
                        fields,
                        nextPesHeaderStore,
                    });
                },
            });
        }
        const packet = await (0, parse_packet_1.parsePacket)({
            iterator,
            structure,
            streamBuffers,
            parserState: state,
            nextPesHeaderStore,
        });
        if (packet) {
            structure.boxes.push(packet);
            break;
        }
    }
    return Promise.resolve({
        segments: structure,
        status: 'incomplete',
        continueParsing() {
            return (0, exports.parseTransportStream)({
                iterator,
                state,
                streamBuffers,
                fields,
                nextPesHeaderStore,
            });
        },
        skipTo: null,
    });
};
exports.parseTransportStream = parseTransportStream;
