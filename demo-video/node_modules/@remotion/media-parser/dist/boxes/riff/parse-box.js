"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseRiff = exports.parseRiffBody = void 0;
const get_tracks_1 = require("../../get-tracks");
const has_all_info_1 = require("../../has-all-info");
const register_track_1 = require("../../register-track");
const expect_riff_box_1 = require("./expect-riff-box");
const get_tracks_from_avi_1 = require("./get-tracks-from-avi");
const traversal_1 = require("./traversal");
const continueAfterRiffBoxResult = ({ result, structure, iterator, maxOffset, state: options, }) => {
    if (result.type === 'incomplete') {
        return Promise.resolve({
            status: 'incomplete',
            async continueParsing() {
                return Promise.resolve(continueAfterRiffBoxResult({
                    result: await result.continueParsing(),
                    structure,
                    iterator,
                    maxOffset,
                    state: options,
                }));
            },
            segments: structure,
            skipTo: null,
        });
    }
    if (result.type === 'complete' && result.box) {
        structure.boxes.push(result.box);
    }
    return (0, exports.parseRiffBody)({ iterator, maxOffset, state: options, structure });
};
const parseRiffBody = async ({ iterator, structure, maxOffset, state, }) => {
    while (iterator.bytesRemaining() > 0 &&
        iterator.counter.getOffset() < maxOffset) {
        const result = await (0, expect_riff_box_1.expectRiffBox)({
            iterator,
            state,
            structure,
        });
        if (result.type === 'complete' && result.skipTo !== null) {
            return {
                status: 'incomplete',
                skipTo: result.skipTo,
                continueParsing() {
                    return Promise.resolve(continueAfterRiffBoxResult({
                        iterator,
                        maxOffset,
                        state,
                        result,
                        structure,
                    }));
                },
            };
        }
        if (result.type === 'incomplete') {
            return {
                status: 'incomplete',
                async continueParsing() {
                    return Promise.resolve(continueAfterRiffBoxResult({
                        iterator,
                        maxOffset,
                        state,
                        result: await result.continueParsing(),
                        structure,
                    }));
                },
                skipTo: null,
            };
        }
        if (result.box === null) {
            continue;
        }
        structure.boxes.push(result.box);
        // When parsing an AVI
        if (result.box.type === 'list-box' && result.box.listType === 'hdrl') {
            const tracks = (0, get_tracks_1.getTracks)(structure, state);
            if (!tracks.videoTracks.some((t) => t.codec === get_tracks_from_avi_1.TO_BE_OVERRIDDEN_LATER)) {
                state.callbacks.tracks.setIsDone();
            }
        }
        // When parsing a WAV
        if (result.box.type === 'wave-format-box') {
            state.callbacks.tracks.setIsDone();
        }
        if (result.box.type === 'strf-box-video' ||
            result.box.type === 'strf-box-audio') {
            const strh = (0, traversal_1.getStrhBox)(structure.boxes);
            const strf = (0, traversal_1.getStrfBox)(structure.boxes);
            if (!strh || !strf) {
                throw new Error('strh or strf box missing');
            }
            if (strf.type === 'strf-box-audio' && state.onAudioTrack) {
                const audioTrack = (0, get_tracks_from_avi_1.makeAviAudioTrack)({
                    index: state.riff.getNextTrackIndex(),
                    strf,
                });
                await (0, register_track_1.registerTrack)({
                    state,
                    track: audioTrack,
                    container: 'avi',
                });
            }
            if (state.onVideoTrack && strf.type === 'strf-box-video') {
                const videoTrack = (0, get_tracks_from_avi_1.makeAviVideoTrack)({
                    strh,
                    index: state.riff.getNextTrackIndex(),
                    strf,
                });
                (0, register_track_1.registerVideoTrackWhenProfileIsAvailable)({
                    state,
                    track: videoTrack,
                    container: 'avi',
                });
            }
            state.riff.incrementNextTrackIndex();
        }
    }
    return {
        status: 'done',
    };
};
exports.parseRiffBody = parseRiffBody;
const parseRiff = ({ iterator, state, fields, }) => {
    const riff = iterator.getByteString(4, false);
    if (riff !== 'RIFF') {
        throw new Error('Not a RIFF file');
    }
    const structure = state.structure.getStructure();
    if (structure.type !== 'riff') {
        throw new Error('Structure is not a RIFF structure');
    }
    const size = iterator.getUint32Le();
    const fileType = iterator.getByteString(4, false);
    if (fileType !== 'WAVE' && fileType !== 'AVI') {
        throw new Error(`File type ${fileType} not supported`);
    }
    structure.boxes.push({ type: 'riff-header', fileSize: size, fileType });
    if ((0, has_all_info_1.hasAllInfo)({ fields, state })) {
        return Promise.resolve({
            status: 'done',
            segments: structure,
        });
    }
    return (0, exports.parseRiffBody)({
        iterator,
        maxOffset: Infinity,
        state,
        structure,
    });
};
exports.parseRiff = parseRiff;
