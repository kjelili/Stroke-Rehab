"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expectSegment = void 0;
const parse_ebml_1 = require("./parse-ebml");
const parse_children_1 = require("./segments/parse-children");
const continueAfterMatroskaParseResult = async ({ result, iterator, state, segment, }) => {
    if (result.status === 'done') {
        throw new Error('Should not continue after done');
    }
    const proceeded = await result.continueParsing();
    if (proceeded.status === 'done') {
        return {
            status: 'done',
            segment,
        };
    }
    return {
        continueParsing() {
            return continueAfterMatroskaParseResult({
                result: proceeded,
                iterator,
                state,
                segment,
            });
        },
        segment: null,
        status: 'incomplete',
    };
};
const expectSegment = async ({ iterator, state, offset, children, fields, topLevelStructure, }) => {
    iterator.counter.decrement(iterator.counter.getOffset() - offset);
    if (iterator.bytesRemaining() === 0) {
        return {
            status: 'incomplete',
            continueParsing: () => {
                return (0, parse_children_1.expectAndProcessSegment)({
                    iterator,
                    state,
                    offset,
                    children,
                    fields,
                    topLevelStructure,
                });
            },
            segment: null,
        };
    }
    const segmentId = iterator.getMatroskaSegmentId();
    if (segmentId === null) {
        iterator.counter.decrement(iterator.counter.getOffset() - offset);
        return {
            status: 'incomplete',
            continueParsing: () => {
                return (0, parse_children_1.expectAndProcessSegment)({
                    iterator,
                    state,
                    offset,
                    children,
                    fields,
                    topLevelStructure,
                });
            },
            segment: null,
        };
    }
    const offsetBeforeVInt = iterator.counter.getOffset();
    const length = iterator.getVint();
    const offsetAfterVInt = iterator.counter.getOffset();
    if (length === null) {
        iterator.counter.decrement(iterator.counter.getOffset() - offset);
        return {
            status: 'incomplete',
            continueParsing: () => {
                return (0, exports.expectSegment)({
                    iterator,
                    state,
                    offset,
                    children,
                    fields,
                    topLevelStructure,
                });
            },
            segment: null,
        };
    }
    const bytesRemainingNow = iterator.byteLength() - iterator.counter.getOffset();
    if (segmentId === '0x18538067' || segmentId === '0x1f43b675') {
        const newSegment = {
            type: segmentId === '0x18538067' ? 'Segment' : 'Cluster',
            minVintWidth: offsetAfterVInt - offsetBeforeVInt,
            value: [],
        };
        const main = await (0, parse_children_1.expectChildren)({
            iterator,
            length,
            children: newSegment.value,
            state,
            startOffset: iterator.counter.getOffset(),
            fields,
            topLevelStructure,
        });
        if (main.status === 'incomplete') {
            return {
                status: 'incomplete',
                continueParsing: () => {
                    return continueAfterMatroskaParseResult({
                        iterator,
                        state,
                        result: main,
                        segment: newSegment,
                    });
                },
                segment: newSegment,
            };
        }
        return {
            status: 'done',
            segment: newSegment,
        };
    }
    if (bytesRemainingNow < length) {
        const bytesRead = iterator.counter.getOffset() - offset;
        iterator.counter.decrement(bytesRead);
        return {
            status: 'incomplete',
            segment: null,
            continueParsing: () => {
                return (0, exports.expectSegment)({
                    iterator,
                    state,
                    offset,
                    children,
                    fields,
                    topLevelStructure,
                });
            },
        };
    }
    const segment = await parseSegment({
        segmentId,
        iterator,
        length,
        state,
        headerReadSoFar: iterator.counter.getOffset() - offset,
    });
    return {
        status: 'done',
        segment,
    };
};
exports.expectSegment = expectSegment;
const parseSegment = async ({ segmentId, iterator, length, state, headerReadSoFar, }) => {
    if (length < 0) {
        throw new Error(`Expected length of ${segmentId} to be greater or equal 0`);
    }
    iterator.counter.decrement(headerReadSoFar);
    const offset = iterator.counter.getOffset();
    const ebml = await (0, parse_ebml_1.parseEbml)(iterator, state);
    const remapped = await (0, parse_ebml_1.postprocessEbml)({ offset, ebml, state });
    return remapped;
};
