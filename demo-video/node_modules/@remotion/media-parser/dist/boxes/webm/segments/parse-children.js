"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expectChildren = exports.expectAndProcessSegment = void 0;
const has_all_info_1 = require("../../../has-all-info");
const segments_1 = require("../segments");
const processParseResult = ({ parseResult, children, state, fields, topLevelStructure, }) => {
    if (parseResult.segment && !children.includes(parseResult.segment)) {
        children.push(parseResult.segment);
        if ((0, has_all_info_1.hasAllInfo)({ fields, state })) {
            return {
                status: 'done',
                segment: parseResult.segment,
            };
        }
        if (parseResult.segment.type === 'Tracks') {
            state.callbacks.tracks.setIsDone();
        }
    }
    if (parseResult.status === 'incomplete') {
        // No need to decrement because expectSegment already does it
        return {
            status: 'incomplete',
            segment: parseResult.segment,
            continueParsing: async () => {
                const newParseResult = await parseResult.continueParsing();
                return processParseResult({
                    children,
                    parseResult: newParseResult,
                    state,
                    fields,
                    topLevelStructure,
                });
            },
        };
    }
    return {
        status: 'done',
        segment: parseResult.segment,
    };
};
const expectAndProcessSegment = async ({ iterator, state, offset, children, fields, topLevelStructure, }) => {
    const segment = await (0, segments_1.expectSegment)({
        iterator,
        state,
        offset,
        children,
        fields,
        topLevelStructure,
    });
    return processParseResult({
        children,
        parseResult: segment,
        state,
        fields,
        topLevelStructure,
    });
};
exports.expectAndProcessSegment = expectAndProcessSegment;
const continueAfterSegmentResult = async ({ result, length, children, state, iterator, startOffset, fields, topLevelStructure, }) => {
    if (result.status === 'done') {
        throw new Error('Should not continue after done');
    }
    const segmentResult = await result.continueParsing();
    if (segmentResult.status === 'done') {
        return {
            status: 'incomplete',
            continueParsing: () => {
                // eslint-disable-next-line @typescript-eslint/no-use-before-define
                return (0, exports.expectChildren)({
                    children,
                    iterator,
                    length,
                    state,
                    startOffset,
                    fields,
                    topLevelStructure,
                });
            },
            skipTo: null,
        };
    }
    return {
        status: 'incomplete',
        continueParsing: () => {
            return continueAfterSegmentResult({
                result: segmentResult,
                children,
                iterator,
                length,
                state,
                startOffset,
                fields,
                topLevelStructure,
            });
        },
        skipTo: null,
    };
};
const expectChildren = async ({ iterator, length, children, state, startOffset, fields, topLevelStructure, }) => {
    while (iterator.counter.getOffset() < startOffset + length) {
        if (iterator.bytesRemaining() === 0) {
            break;
        }
        const currentOffset = iterator.counter.getOffset();
        const child = await (0, exports.expectAndProcessSegment)({
            iterator,
            state,
            offset: currentOffset,
            children,
            fields,
            topLevelStructure,
        });
        if ((0, has_all_info_1.hasAllInfo)({
            fields,
            state,
        })) {
            return {
                status: 'done',
            };
        }
        if (child.status === 'incomplete') {
            return {
                status: 'incomplete',
                continueParsing: () => {
                    return continueAfterSegmentResult({
                        result: child,
                        children,
                        iterator,
                        length: length - (currentOffset - startOffset),
                        state,
                        startOffset: currentOffset,
                        fields,
                        topLevelStructure,
                    });
                },
                skipTo: null,
            };
        }
    }
    return {
        status: 'done',
    };
};
exports.expectChildren = expectChildren;
